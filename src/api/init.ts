import * as fcl from "@onflow/fcl"
import * as t from "@onflow/types"
import FCLContract from "cadence/contracts/FCL.cdc"
import initTransaction from "cadence/transactions/init.cdc"
import {accountLabelGenerator} from "src/accountGenerator"
import {authz} from "src/authz"
import {SERVICE_ACCOUNT_LABEL} from "src/constants"
import {encodeServiceKey} from "src/crypto"
import fclConfig from "src/fclConfig"

const init = async () => {
  fclConfig(
    process.env.NEXT_PUBLIC_FLOW_ACCESS_NODE!,
    process.env.NEXT_PUBLIC_FLOW_ACCOUNT_ADDRESS!
  )

  const autoGeneratedLabels = [
    ...Array(process.env.NEXT_PUBLIC_FLOW_INIT_ACCOUNT),
  ].map((_n, i) => accountLabelGenerator(i))
  const initAccountsLabels = [SERVICE_ACCOUNT_LABEL, ...autoGeneratedLabels]

  const authorization = await authz(
    process.env.NEXT_PUBLIC_FLOW_ACCOUNT_ADDRESS!,
    process.env.NEXT_PUBLIC_FLOW_ACCOUNT_KEY_ID!,
    process.env.NEXT_PUBLIC_FLOW_ACCOUNT_PRIVATE_KEY!
  )

  try {
    const txId = await fcl
      .send([
        fcl.transaction(initTransaction),
        fcl.args([
          fcl.arg(Buffer.from(FCLContract, "utf8").toString("hex"), t.String),
          fcl.arg(
            encodeServiceKey(process.env.NEXT_PUBLIC_FLOW_ACCOUNT_PUBLIC_KEY!),
            t.String
          ),
          fcl.arg(initAccountsLabels, t.Array(t.String)),
        ]),
        fcl.proposer(authorization),
        fcl.payer(authorization),
        fcl.authorizations([authorization]),
        fcl.limit(200),
      ])
      .then(fcl.decode)

    await fcl.tx(txId).onceSealed()

    fcl
      .account(process.env.NEXT_PUBLIC_FLOW_ACCOUNT_ADDRESS!)
      .then((d: {contracts: Record<string, unknown>}) => {
        // eslint-disable-next-line no-console
        console.log("ACCOUNT", Object.keys(d.contracts))
      })
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error("TX:ERROR", error)
  }
}

export default async function API_Init() {
  await init()
}
